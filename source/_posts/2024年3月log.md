#### 3/1
1. `vite`中`import.meta.glob(xxx, {query:"?raw"})`是返回一个`default`方法其中是字符串格式的内容，和`as raw`是不一样的，`as raw`是直接返回一个字符串，而不是一个方法，`erger:true`是立即加载

#### 3/5
1. 今天是周二，周一和周二这两天都在解决bi二开，tabs联动数据不实时的问题，主要原因是渲染容器存在多个，主要原因是，为了先显示组件，而不是在全部加载完成后在加载，所以我会做一次预渲染，但是这样交互组件在第一次渲染的时候已经初始化了，又由于我使用的mitt，每一次的on，都会在原用的基础上添加一次响应，所以每一次我都会off一次，这样的话就会造成，数据的不适合，或者说不对应，所以在第一次预渲染的时候，我会排除交互组件，今天也看了一下mitt的源码，也是就是map对象，然后属性值是一个数组，当然我觉得这种方式是不太友好的，我觉得还是mitt的off问题，要想个方法解决一下

#### 3/7
1. BI二次开发问题，问题是二次开发时，使用多个渲染引擎的关系，并且需要小屏控大屏，目前的二次开发其实就是通过每个页面的json文件形成一个页面文件，如果需要修改的话，可以使用`@xt-bi/editor-engine`中的api，进行图层的修改，这次排查的问题是基于湖滨项目，
- 问题一：
    页面的interactive-tabs切换会不管用，因为tabs的交互逻辑使用的是当前渲染容器的数据，进行dataMap，也就是找出对应映射字段的数据进行驱动，如果一个页面存在多个渲染容器，就会造成数据的不对应，就会导致dataMap的结果是错误的，从而导致切换时没有数据联动，那么解决方法就是使用一个渲染容器，另外一种方式就是，依然使用多个渲染容器，但是我会收集当前页面的所有渲染容器所用到的数据，这样在每次进行数据映射的时候，保持正确的数据，但是为什么开发人员会使用多个渲染容器呢？给我的反馈是，如果更新某一个组件，会导致其他组件的刷新，因为他是直接修改数据源，并且重新进行setState，那能不刷新吗，一定要使用`@xt-bi/editor-engine`的api进行修改，因为引擎内部会自动的帮你更新
- 问题二：
   全局组件如何更新，例如大屏的头部导航栏，需要小屏控大屏，一般全局组件会放在`layout`里面，使用渲染容器进行渲染，也就是说在改变`layout`里面的数据时，还是会有两个容器进行渲染，一个是`layout`里面的一个是当前页面的，这样使用`@xt-bi/editor-engine`的api进行修改会有问题，因为他找不到需要更新的数据是哪一个容器的，就会造成页面出现重复元素，所以这个需要直接修改数据源
- 问题三：
    这个也是我还没有想到解决方法的一个问题，其实以上所有的问题都是因为我对页面进行了预渲染，也就是会先渲染一次元素，请求之后再渲染一次，也就是我`3/5`记录的问题，需要学习一下其他的低代码平台，是如何操作的，另外一个就是使用多个容器时，如果记住每一个容器对应的数据，而不是像我现在这样进行总和


#### 3/10
1. eyeDropper取色器，兼容性较低
2. jwt,头部，栽荷、密钥，主要防止被篡改
3. pnpm解决了幽灵依赖的问题
4. 三维重建的学习