#### 9/4
1. [css round()](source/_posts/2023年8月log.md)
1. [微内核架构](https://mp.weixin.qq.com/s/rf-onLvIVIFP6XGGuIVG9Q)
 - 管道式插件
 - 洋葱式插件
 - 事件式插件

#### 9/5
1. [3d的设计模式](https://yyc-git.github.io/3dProgramPattern/docs/%E4%BE%9D%E8%B5%96%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F/#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%96%99%E6%8E%A8%E8%8D%90)
2. [完善的前端异常监控解决方案](https://mp.weixin.qq.com/s/ndRqZZtY79VmwIjcOT8V2A)
3. [前端异常监控代码示例](https://mp.weixin.qq.com/s/mEz3Dcr06V7wYhhp6fBSRw)

#### 9/11
在UML（统一建模语言）中，关联关系和依赖关系是两种不同的关系，它们用于描述类、对象或组件之间的连接和交互。以下是它们之间的区别：

**关联关系（Association）**：

1. **定义**：关联关系表示两个或多个类之间的连接，通常用于描述类之间的结构关系，表示类之间有某种关联或连接。

2. **性质**：关联关系可以具有方向性，即可以是双向的（双向关联）或单向的（单向关联）。它可以是一对一、一对多、多对一或多对多的关系。

3. **用途**：关联关系用于表示类之间的结构关系，它描述了类之间如何连接和交互。例如，一个学生类和一个课程类之间可以有关联关系，表示学生选修了多门课程。

4. **表示**：在UML图中，关联关系通常用一条线连接两个类，可以在线上标记关联的性质和多重性。

**依赖关系（Dependency）**：

1. **定义**：依赖关系表示一个类（或对象或组件）使用或依赖于另一个类，但没有实际的拥有关系。它通常用于描述类之间的运行时关系。

2. **性质**：依赖关系是一种弱关系，它表示一个类的变化可能会影响到另一个类，但不涉及实际的连接或拥有关系。

3. **用途**：依赖关系用于表示一个类在运行时需要访问另一个类的某些功能或数据。例如，一个类的方法中使用了另一个类的对象作为参数，表示它依赖于那个类。

4. **表示**：在UML图中，依赖关系通常用一条带箭头的虚线表示，箭头指向被依赖的类。

总结来说，关联关系用于描述类之间的结构连接，而依赖关系用于描述类之间的运行时依赖。关联关系通常具有更强的耦合，因为它表示类之间的实际连接，而依赖关系表示更松散的关系，一个类只是依赖于另一个类的某些功能或数据。在进行UML建模时，根据具体的情况选择合适的关系类型来准确地表示类之间的关系非常重要。

#### 9/12
1. [文件下载](https://mp.weixin.qq.com/s/FDN6vttUQF51u2klC0l2IA)

#### 9/13
1. 缓冲区(Buffer)

  - 高效的数据存储和传输：缓冲区提供了一种高效的方式来存储和传输图形数据，如顶点数据、索引数据和其他自定义数据。它们可以在图形处理单元（GPU）中进行高速处理，从而提高渲染性能。

  - 减少内存占用：通过使用缓冲区，可以将图形数据存储在显存（VRAM）中，而不是系统内存（RAM）中。这样可以减少内存占用，使得应用程序可以处理更大规模的图形数据。

  - 快速渲染和绘制：缓冲区可以被图形硬件直接访问和处理，从而实现快速渲染和绘制。例如，使用索引缓冲区可以减少需要绘制的顶点数量，提高渲染性能。

  - 灵活的数据处理：缓冲区可以存储各种类型的数据，如顶点数据、纹理数据、光照参数等。这使得开发者可以自由地处理和操作这些数据，实现各种复杂的渲染效果和图形处理算法。

  - 易于与图形API集成：缓冲区是图形API（如OpenGL、DirectX等）中的常见概念，因此它们与这些API的集成非常方便。现代图形框架和引擎（如Babylon.js）提供了高级的接口和工具，使得创建和管理缓冲区变得更加简单和可靠。

2. 显存和内存的区别
  - 用途不同：显存主要用于存储和处理图形数据，如图像、纹理、缓冲区等。它是图形处理单元（GPU）专用的存储器，用于加速图形渲染和图形计算。内存用于存储计算机程序和数据，包括操作系统、应用程序和其他临时数据。

  - 访问速度不同：显存的访问速度通常比内存更快。这是因为显存被设计用于高速图形处理，它与图形处理器（GPU）紧密集成，可以提供更快的数据传输和处理能力。内存虽然也很快，但它通常无法与显存相媲美。

  - 容量不同：显存的容量通常比内存较小。这是因为显存需要存储大量的图形数据，并且需要保持较高的带宽和访问速度。内存通常具有比显存更大的容量，以满足计算机系统的多种需求。

  - 数据类型不同：显存主要用于存储图像和图形数据，它支持特定的图形数据格式和操作。内存则用于存储各种类型的数据，包括程序代码、变量、临时数据等。

  - 可扩展性不同：显存的扩展性通常较弱。显存容量的增加通常需要更换显卡或升级硬件。内存则具有更高的可扩展性，可以通过添加更多的内存模块来增加容量。

#### 9/14
1. 后期处理postprocess
 BABYLON.PostProcess 和 BABYLON.PostProcessRenderPipeline 在使用方式和功能上有一些区别。
  使用方式：

  BABYLON.PostProcess 用于创建单个后期处理效果。你可以创建一个 BABYLON.PostProcess 对象，定义一个后期处理效果，并将其应用于场景渲染的最终结果。
  BABYLON.PostProcessRenderPipeline 用于创建自定义的后期处理渲染管线。你可以创建一个 BABYLON.PostProcessRenderPipeline 对象，然后使用 addEffect 方法将多个 BABYLON.PostProcess 对象添加到管线中，并以指定的顺序应用这些效果。

  功能：
  BABYLON.PostProcess 允许你创建各种后期处理效果，如模糊、色彩校正、光晕等。你可以通过编写着色器代码和设置相关参数来自定义后期处理效果。
  BABYLON.PostProcessRenderPipeline 允许你创建自定义的后期处理渲染管线，将多个后期处理效果组合在一起，并以指定的顺序应用这些效果。你可以根据需求添加多个自定义的后期处理效果，以实现不同的图像效果。

  应用范围：
  BABYLON.PostProcess 可以应用于单个相机或渲染目标，以实现特定的后期处理效果。你可以为每个相机或渲染目标创建一个或多个后期处理效果。
  BABYLON.PostProcessRenderPipeline 可以应用于整个场景，同时影响所有相机和渲染目标。你可以创建一个渲染管线，将多个后期处理效果添加到管线中，并在场景中的所有相机和渲染目标上应用这些效果。
  总的来说，BABYLON.PostProcess 用于创建单个后期处理效果，而 BABYLON.PostProcessRenderPipeline 用于创建包含多个后期处理效果的自定义渲染管线，并将其应用于整个场景。

2. gameObject和component
在三维引擎中，"gameObject"（游戏对象）和"component"（组件）是两个核心概念。

gameObject（游戏对象）是引擎中最基本的实体，代表游戏世界中的一个物体或角色。它可以是一个可见的对象（如角色、道具、场景中的物体等），也可以是一个抽象的对象（如灯光、相机等）。游戏对象通常由一个或多个组件组成，用于定义其行为和外观。

component（组件）是游戏对象的可组合部分，用于赋予游戏对象特定的功能和行为。每个组件都负责处理游戏对象的某个方面，例如渲染、碰撞检测、物理模拟、动画、声音等。通过将不同类型的组件组合到游戏对象上，可以实现复杂的行为和功能。

游戏对象和组件之间存在一种父子关系。游戏对象可以拥有多个子对象，这些子对象也可以是游戏对象，形成对象的层次结构。每个游戏对象可以附加一个或多个组件，这些组件定义了游戏对象的行为和功能。

例如，一个角色游戏对象可以附加一个渲染组件、一个动画组件和一个碰撞检测组件。渲染组件负责将角色渲染到屏幕上，动画组件负责处理角色的动作和动画效果，碰撞检测组件负责检测角色与其他物体的碰撞。

通过游戏对象和组件的概念，开发者可以使用组合的方式来构建复杂的游戏世界和交互体验。

希望这个解释对你有帮助。如果你对游戏对象和组件还有其他问题，请随时提问。

3. ECS模式

#### 9/18
1. 代码逻辑尽量不要都写在中间成，注意关注点分离
2. gameObject的更新

#### 9/19
1. 第一人称相机（FreeCamera）和鸟瞰相机（arcRotateCamera）的区别
鸟瞰相机的选择围绕的是目标点进行旋转，而第一人称的目标点是相机，例如在游戏场景中，通过键盘控制相机的角度，是基于相机的水平角度（yaw）和垂直角度（pitch）的变化
2. 倾斜修正（Tilt Correction）通常用于调整相机的旋转角度，以确保相机在特定情况下（例如俯仰、倾斜）保持在所需的姿势。这可以通过以下步骤来实现：

1. **检测需要倾斜修正的情况：** 首先，你需要确定何时需要进行倾斜修正。这通常包括检测相机的俯仰（垂直旋转角度）和倾斜（水平旋转角度）是否超出了某个阈值。

2. **计算修正角度：** 如果相机的俯仰和倾斜超出了阈值，就需要计算修正角度。修正角度通常是将相机的俯仰和倾斜角度调整到所需的角度。

3. **应用修正角度：** 使用计算出的修正角度来调整相机的旋转角度，以实现倾斜修正。这通常涉及到设置相机的 `alpha`（水平旋转角度）和 `beta`（垂直旋转角度）属性。

以下是一个示例，演示如何在 Babylon.js 中进行倾斜修正：

```javascript
function applyTiltCorrection(camera, maxTiltAngle, maxPitchAngle) {
  // 获取当前相机的俯仰（beta）和倾斜（alpha）角度
  const currentBeta = camera.beta;
  const currentAlpha = camera.alpha;

  // 判断是否需要倾斜修正
  if (Math.abs(currentBeta) > maxPitchAngle || Math.abs(currentAlpha) > maxTiltAngle) {
    // 计算修正角度，将角度限制在指定的范围内
    const correctedBeta = Math.min(Math.max(currentBeta, -maxPitchAngle), maxPitchAngle);
    const correctedAlpha = Math.min(Math.max(currentAlpha, -maxTiltAngle), maxTiltAngle);

    // 应用修正角度
    camera.beta = correctedBeta;
    camera.alpha = correctedAlpha;
  }
}

// 调用 applyTiltCorrection 函数来进行倾斜修正
const maxTiltAngle = Math.PI / 4;   // 最大倾斜角度
const maxPitchAngle = Math.PI / 6;  // 最大俯仰角度

applyTiltCorrection(camera, maxTiltAngle, maxPitchAngle);
```

上述示例中，`applyTiltCorrection` 函数会检测相机的俯仰和倾斜角度是否超出指定的阈值，如果超出，则计算修正角度并将其应用于相机，以确保相机在指定的范围内倾斜修正。你可以根据需要调整 `maxTiltAngle` 和 `maxPitchAngle` 的值来控制修正的程度。