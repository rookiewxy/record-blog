#### 9/1
1. 函数的二义性
   - 指令序列
   - 构造器
这也是箭头函数盒普通函数最本质的区别，在一个正统语言里面，这两者之前的意思不一样，那么他的语法层面应该是分开的，es6之后就修复了这个问题，比如Class只能new调用，箭头函数不能new调用


#### 9/4
1. 今天周三，实现动画路径绘制中的marker，在浏览器缩放时，进行大小限制，因为放大场景到一定距离，marker就会显示的非常大，感官上特别不好，这个功能做了两天，核心代码
```ts
this.scene.registerBeforeRender(()=>{
   const meshes = this.getMarkers();
    meshes?.forEach((mesh) => {
      const d = this.getScaleRatio(mesh);
      mesh.scaling = new Vector3(d, d, d);

      // scaling之后，再打点时，marker是有一半在地下的，所以需要抬高缩放的距离
      const raduis = mesh.scaling.x * 0.05;
      // 直接修改y没有问题，但是如果是整个position复制，例如 mesh.position = new Vector3(d,raduis,d)在拖拽marker的时候绘制的path就不会更新
      mesh.position.y = raduis
    });
});
```

#### 9/5
1. 做了一个babylon的小demo，绘制一个带有边框的平面，其中显示文字，在cesium或者threejs应该很容易实现
其中创建一个面以及绘制出边框很简单，但是绘制文本出现了问题，肯定不能使用2d，因为不会跟随场景移动，因此使用动态贴图，如果你需要你在动态贴图上设置多个元素
，需设置[container](https://playground.babylonjs.com/#ZMCFYA#316)，创建贴图之后，会导致polygon区域颜色不显示，因此不能直接作用于polygon而是需要再polygon的基础上在设置一个父级
parent，贴图作用于parent，此时可以正常显示，但是文字是垂直于平面的因此，需要将parent进行旋转，因为是基于parent的
```ts
const createScene = function() {
    const scene = new BABYLON.Scene(engine);

    // 创建相机
    const camera = new BABYLON.ArcRotateCamera("Camera", 0, Math.PI / 3, 20, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);

    // 添加光源
    const light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // 创建多边形形状
    const shape = [
        new BABYLON.Vector3(4, 0, -4),
        new BABYLON.Vector3(2, 0, 0),
        new BABYLON.Vector3(5, 0, 2),
        new BABYLON.Vector3(1, 0, 2),
        new BABYLON.Vector3(-5, 0, 5),
        new BABYLON.Vector3(-3, 0, 1),
        new BABYLON.Vector3(-4, 0, -4),
        new BABYLON.Vector3(-2, 0, -3),
        new BABYLON.Vector3(2, 0, -3)
    ];

    // 创建多边形
    const polygon = BABYLON.MeshBuilder.CreatePolygon("polygon", { shape: shape, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
 
    const material = new BABYLON.StandardMaterial("yellowMaterial", scene);
    material.emissiveColor = new BABYLON.Color3(0, 0.58, 1); // 降低反光
    material.backFaceCulling = false; // 禁用背面剔除
    material.alpha = 0.2

    polygon.material = material;

    polygon.bakeCurrentTransformIntoVertices();
     
    polygon.enableEdgesRendering();
    polygon.edgesWidth = 6.0;  // 边框宽度
    polygon.edgesColor = new BABYLON.Color4(1, 1, 1); // 红色边框

    const plane = BABYLON.MeshBuilder.CreatePlane("textPlane", { size: 10 }, scene);
    plane.parent = polygon;
    plane.rotation.x = Math.PI / 2;
    plane.position.y += 0.01;

    // 创建动态纹理用于显示文本
    const texture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(plane);

    // 添加文本
    const textBlock = new BABYLON.GUI.TextBlock();
    textBlock.text = "内蒙古";
    textBlock.color = "white";
    textBlock.fontSize = 50;
    texture.addControl(textBlock);

    return scene;
};

```

#### 9/9
1. 今天做的vue的大屏开发，在做响应式的大屏式，最好还是写固定的宽高，也就是封装的panel设置width和height两个值，要不然很容易左右面板长度不一致
2. 打包“/”和“./”是一样的