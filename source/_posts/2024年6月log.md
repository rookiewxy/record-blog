#### 6/1
1. 优化BI初始化加载速度，定位问题发现是在初始化时就加载了物料组件的相关文件，后来发现是`eager`的问题，可看三月一号的日志，因为这个是默认全部加载，如果为false就是懒加载
2. 学习了其他低代码平台(vitis)的物料组件的加载方式，发现别人通过组件的tsx文件自动生成json文件，其中需要用到[ts CompileAPI](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API),搭配[react-docgen-typescript](https://github.com/styleguidist/react-docgen-typescript),该组件的作用是通过interface中定义的props自动生成props的类型、描述的json信息
- scripts 的生命周期
- findConfig 查找文件路径
- safe-eval 安全检查


#### 6/7
1. [解决ollama本地跨域问题](https://blog.csdn.net/QiZi_Zpl/article/details/137133486)


#### 6/12
1. amis
 - [react-json-view](https://github.com/mac-s-g/react-json-view)
 - [react-markdown](https://remarkjs.github.io/react-markdown/)
 - [react-syntax-highlighter](https://github.com/react-syntax-highlighter/react-syntax-highlighter)


#### 6/13
1. 米氏散射、瑞利散射其实就是光散射的不同阶段，根据波光长度的不同会有不一样的散射效果，https://ipt.jnu.edu.cn/fobg/2021/0816/c32235a641303/page.htm

#### 6/14
1. 今天主要完成BI中的阴影模块
2. 模型资产库的保存方法优化，使用git diff 找出哪些变化的组件
```ts
import { execSync } from "child_process";
const files = execSync(`git diff --name-only ${ASSET_DIR}`).toString()?.split("\n")?.filter(Boolean);
```
3. 第二点有个问题就是，如果这个文件是新疆的就回查找为空，使用status
```bash
git status -s ${DIR} | awk '{print $2}'
``` 


#### 6/15
1. 抽象类在编译之后抽象方法会删掉，因为抽象方法中设置了 参数类型，实现的子类依然没有提示，需要手动设置
https://ts.nodejs.cn/play?&q=402#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgWQgBNgAbABUykwFsBnOAbwCg44BXKUgLjjpijIA5gG5mAX2bMYATzB4AggB4AKgD44AXjgq4oVEiINk6NHACqcAPwW4vFWKmYARv2rZ42UpjoMAQj7AqtqEJBRUtHRqLKxscC5uOJ5QwJioABRgEfTcKgCU3ABuEAhEElJePv6BAEzBBMRklNT00VJxbNgpacCZ2XS5eSwdHbFxkpLMlb5wACIQQnogBkZwAXTANcNx2BBIbuwe0OlDYyN07PJQJ2cdMAAWCHQAdF2pGXlnExXeMwDCaUQNDApGANGAKGqG22nW6HxiHW+zCQwAA7nAATATkA

2. 在 PBR（Physically Based Rendering，物理基础渲染）模型中，传统意义上的 `diffuseColor` 并不存在。PBR 模型使用了更物理精确的属性来描述材质的光照特性，其中最主要的颜色属性是 `albedoColor`。PBR 模型的设计目标是通过更准确地模拟光与材质的交互来实现更真实的渲染效果。

### 传统渲染与 PBR 渲染的对比

#### 传统渲染

在传统的光照模型（如 Blinn-Phong 和 Lambert）中，通常会使用以下属性：

- **diffuseColor**：表示材质的漫反射颜色，即材质在漫反射光照下的颜色。
- **specularColor**：表示材质的镜面反射颜色，即材质在镜面反射光照下的颜色。

这些属性用于计算光线在材质表面上的散射和反射，通常较为简单，不一定物理精确。

#### PBR 渲染

在 PBR 模型中，材质属性更加物理精确，主要使用以下属性：

- **albedoColor**：表示材质的基础颜色，不受光照强度和方向的影响。它相当于在均匀光照下材质的颜色。
- **metallic**：定义材质的金属性，决定材质是金属还是非金属。
- **roughness**：定义材质表面的粗糙度，影响光线的散射和反射的模糊程度。
- **ambientOcclusion**：环境光遮蔽，用于模拟细节阴影。
- **normalMap**：法线贴图，用于细化表面细节和凹凸效果。

### 为什么没有 `diffuseColor`

1. **物理精确性**：PBR 模型旨在通过物理准确的属性来模拟材质和光照的交互。`albedoColor` 更加精确地表示材质在不同光照条件下的反射特性，而不是简单的漫反射颜色。
2. **综合属性**：PBR 模型综合考虑了漫反射和镜面反射的效果，不再单独使用 `diffuseColor` 和 `specularColor`。相反，通过 `albedoColor`、`metallic` 和 `roughness` 等属性组合来实现更真实的光照效果。
3. **统一处理**：PBR 模型统一处理金属和非金属材质的光照特性，通过 `metallic` 属性区分金属和非金属材质，不需要单独的 `diffuseColor` 和 `specularColor`。


在这个示例中，`albedoColor` 取代了传统的 `diffuseColor`，用于定义材质的基础颜色。`metallic` 和 `roughness` 属性控制材质的光照反射特性，提供了比传统模型更为精确的材质表现。

### 总结

PBR 模型不再使用传统的 `diffuseColor`，而是通过 `albedoColor` 来表示材质的基础颜色。`albedoColor` 与 `metallic` 和 `roughness` 等属性结合，能够更准确地模拟材质在不同光照条件下的表现，从而实现更为真实的渲染效果。这种方式提高了渲染的物理准确性和一致性，使得 PBR 成为现代计算机图形学中的主流光照模型。


#### 6/19
1. 使用MeshBuilder.CreateBox创建的盒子，是不能直接修改宽高的，因为
创建后的网格（如 Box）的长宽高是通过其几何体数据（顶点数据）定义的。网格的顶点数据在创建时被固定下来，如果想要直接修改宽高，需要更新这些顶点数据。WebGL 不允许直接修改网格的尺寸属性（宽高深），因为这些属性在初始化几何体时被固定下来并存储在 GPU 内存中。

然而，Babylon.js 提供了几种间接修改网格尺寸的方法：

使用缩放属性：
缩放是最常用的方式，简单且高效。

重新创建网格：
这种方法虽然简单，但不总是最优的，特别是在复杂场景中。

修改顶点数据：
最灵活但也是最复杂的方法。


#### 6/24
1. 今天完成BI的形状图形的阴影模块以及图层列表菜单的bug修复
2. 储备React转Vue代码的知识，很多低代码平台只支持一种框架的转换，或者有的引擎支持自定义扩展插件来完成转换例如（lowcode-engine）
3. react-runtime的两种模式classic个autoMatic,两者的区别如下

在 React 中，Runtime 指的是 JSX 代码在运行时被处理和执行的方式。而 Classic 和 Automatic 是两种不同的 Runtime 模式，影响着 JSX 代码的编译和最终生成的代码。

**1. Classic Runtime**

* **传统模式:**  这是 React 16.x 版本以前默认的 JSX Runtime 模式。
* **原理:**  JSX 代码被编译成 `React.createElement` 函数调用，需要在使用 JSX 的地方显式导入 `React` 模块。
* **示例:**

```javascript
import React from 'react';

function MyComponent() {
  return <div>Hello, World!</div>;
}

// 编译后的代码
import React from 'react';

function MyComponent() {
  return React.createElement('div', null, 'Hello, World!');
}
```

* **缺点:** 
    * 需要在每个使用 JSX 的文件中导入 `React`，增加了代码体积。
    * `React.createElement` 效率较低，尤其是对于大型应用。


**2. Automatic Runtime**

* **自动模式:**  这是 React 17 版本引入的新的 JSX Runtime 模式，默认情况下被启用。
* **原理:**  JSX 代码被编译成 `jsx` 或 `jsxDev` 函数调用，这些函数来自 `react/jsx-runtime` 或 `react/jsx-dev-runtime` 模块。这些模块会自动导入到代码中，无需显式导入 `React` 模块。
* **示例:**

```javascript
function MyComponent() {
  return <div>Hello, World!</div>;
}

// 编译后的代码
import { jsx as _jsx } from 'react/jsx-runtime';

function MyComponent() {
  return _jsx('div', { children: 'Hello, World!' });
}
```

* **优点:**
    * 不需要导入 `React`，减少了代码体积。
    * `jsx` 或 `jsxDev` 函数的效率更高。
    * 为未来的优化提供了更多空间。


**选择哪种模式？**

* **通常情况下，建议使用 Automatic Runtime 模式，因为它更加高效，代码更简洁。**
* **如果你需要使用一些 React 16.x 版本以前的功能，或者你需要与旧的 JSX 转换工具兼容，则可以使用 Classic Runtime 模式。**

**需要注意的是，Automatic Runtime 模式仅适用于 React 17 版本及以上。如果你使用的是 React 16.x 版本，则只能使用 Classic Runtime 模式。**

希望以上解释能够帮助您理解 React Runtime 中的 Classic 和 Automatic 模式。
