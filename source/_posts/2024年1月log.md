#### 1/2

1. 手写jest
2. [saas化服务的设计](https://mp.weixin.qq.com/s/inF6TQjDKFcD7fef2c7rbQ)
3. promise的用法
4. debugger调试

#### 1/3
1. 在低代码平台中，会有一个问题就是在进行页面切换的时候，会造成需要等待一个页面的数据加载完成之后在进行渲染，虽然二开中的导出工程可以解决这个问题，因为这是路由切换，但是在在线预览的时候就会造成阻塞，所以我们需要预渲染，但是在我们的BI平台当时如果直接使用预渲染，一些`interactive`组件就回造成已经加载完成一次了，他的初始化事件已经注册了，在进行第二次渲染的时候，初始化事件已经不会绑定，就回失效，所以我现在的解决方式是，预渲染的时候不加载`interactive`相关组件
2. 今天还看到了其他低代码平台是如果实现两个组件的联动，他时候的是customEvent自定义更新，例如该[案例](https://mp.weixin.qq.com/s/eHYEk7mEKR6mWOn3p_2Fvg)

#### 1/4
1. 虽然工作很久了，但是今天需要，回顾了一下盒子模型，`offsetHeight`和`clientHeight`的区别[https://blog.csdn.net/qq_40890601/article/details/122018917]
2. 监听元素变化，可以直接使用`ahooks`中的`useSize`,其实就是基于`ResizeObserver`的二次封装
3. mxdraw在线预览dwg文件，但是看了他们的node服务，还是会有试用期的限制，并且执行的脚本用c++编写为后缀node的文件

#### 1/5
1. 不小心把未提交的文件进行了撤回，如何找到丢失的代码,使用[git cat-file](https://www.cnblogs.com/wang1229/p/16412331.html)找回


#### 1/6
1. child_process.spawn和child_process.exec的区别:
child_process.exec 是 Node.js 提供的另一个模块，用于在 Node.js 程序中执行 shell 命令，并获取其输出。相比于 child_process.spawn，child_process.exec 提供了更简单的方式来执行命令，但在某些情况下可能会有性能上的差异。

下面是一些 child_process.exec 和 child_process.spawn 的区别：

参数传递方式：child_process.exec 接受一个命令字符串作为参数，而 child_process.spawn 接受一个可执行文件的路径以及一个参数数组作为参数。

输出处理：child_process.exec 的回调函数会接收到整个命令的输出，包括标准输出和错误输出，可以通过解析字符串来获取需要的信息。而 child_process.spawn 提供了分别监听标准输出和错误输出的事件，可以在事件回调中逐行处理输出，而不需要将整个输出保存在内存中。

性能：child_process.exec 在执行命令时，会首先启动一个 shell 进程，然后在该 shell 中执行命令。这个过程会增加一些额外的开销。而 child_process.spawn 直接启动指定的可执行文件，不需要额外的 shell 进程，所以在某些情况下可能会有更好的性能表现。

一般来说，如果你只需要执行简单的命令并获取其输出，可以选择使用 child_process.exec。如果你需要更细粒度地控制子进程的行为，或者处理大量的输出数据，可以选择使用 child_process.spawn。
2. [js文章网站](https://javascript.sumankunwar.com.np/en/design-patterns/)