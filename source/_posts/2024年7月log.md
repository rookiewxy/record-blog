#### 7/2
1. 今天遇到一个关于表单当中使用tooltip的bug,比如使用inputNumber组件在外面包裹一层ToolTip，inputNumber内部的value变化是实时更新的，但是放在form里面就不行了，代码如下
```tsx
   import {
  Form,
  InputNumber,
  Tooltip,
} from '@xt-ui/core';
// 这里通过form?.current?.setFieldsValue是不会生效的，antd也是如此
<Form>
   <Form.Item name="value">
        <Tooltip overlay={'111'}>
            <InputNumber />
        </Tooltip>
   </Form.Item>
</Form>
#### 7/1
1. 今天做的是三维场景相机部分，遇到一个问题就是使用cameraGizmo的时候需要创建两个相机才有效果

// 这种方式可以
<Form>
   <Tooltip overlay={'111'}>
       <Form.Item name="value">
            <InputNumber />
       </Form.Item>
   </Tooltip>
</Form>
```
2. 实现PromiseAll
```ts
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise<string>((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

declare function PromiseAll<T extends any[]>(arr: readonly [...T]):
Promise<{ [K in keyof T]:T[K] extends Promise<infer P> ? P :T[K]}>

const p = PromiseAll([promise1, promise2, promise3] as const)
```

#### 7/3
1. markdown的图标https://shields.io/
2. 
```ts
type Replace<S extends string, K extends string, V extends string>= 
S extends `${infer F}${K}${infer E}` ? `${F}${V}${E}`:S

type replaced = Replace<'types are fun!', 'fun', 'awesome'> // 期望是 'types are awesome!'
```

#### 7/4
1. 在跟随相机绑定目标时，需要先绑定动画，动画是绑定在camera上，因为是camera在移动，如果是绑定在物体上，效果就是gizmo的视口区域在移动，而不是整个相机在移动
[查看效果](https://playground.babylonjs.com/#Z4ZGAY#47)
2. 学习animation模块，发现了ACE编辑器，以及begineAnimation和beigneDirectAnimation
在 Babylon.js 中，`beginDirectAnimation` 和 `beginAnimation` 都可以用来播放动画，但它们之间有一些关键区别：

**`beginAnimation`** 

* **基于关键帧**:  这个方法主要用于播放基于关键帧的动画，你需要预先定义好动画关键帧以及每个关键帧的值。 [5](https://forum.babylonjs.com/t/animatedmodel-play/184)
* **可循环**: 可以设置动画循环播放，例如来回循环或者一次性播放。
* **可应用于多种属性**: 可以用来动画多种属性，例如位置、旋转、缩放、颜色等等。

**`beginDirectAnimation`**

* **直接控制属性**:  这个方法允许你直接控制动画属性值的变化，而不是依赖于预先定义的关键帧。 [6](https://stackoverflow.com/questions/64999410/difference-between-babylon-animation-and-scene-registerbeforerender)
* **更灵活**: 你可以在每一帧中动态地改变动画属性值，实现更灵活的动画效果。
* **通常用于简单动画**: 比较适合于简单的、不需要预设关键帧的动画，例如线性移动、匀速旋转等。

**总结:**

* 如果你需要创建复杂的、基于关键帧的动画，使用 `beginAnimation`。
* 如果你需要更灵活地控制动画，或者创建简单的动画效果，使用 `beginDirectAnimation`。 
* `beginDirectAnimation` 在性能方面可能略优于 `beginAnimation`，因为它不需要计算关键帧之间的插值。

希望这些解释能够帮助你理解 `beginDirectAnimation` 和 `beginAnimation` 的区别! 


#### 7/4

1. 关于python项目的初始化
 - 如果项目还没有venv环境请使用该命令创建
 ```bash
 python -m venv venv
 ```
- 如果项目已经存在venv，使用该命令激活
```bash
# windows使用
xxx\venv\Scripts\activate
# macos
source xxx\venv\Scripts\activate
```
- 创建requrements.text
```bash
python freeze > requirements.text

# 安装
pip install -r requrements.text
```

#### 7/8
1. 实现appendObject的功能，下面是其中一种解法，我觉得很巧妙的一点是使用omit
```ts
type Test = { id: '1' }

type AppendToObject<T, K extends keyof any, V> = Omit<T & {[P in K]:V}, never>
```


#### 7/9
1. 记录一下学习amis中自定义动作的小启发，低代码平台的组件数据都是通过`json`来驱动，现在我要自动动作应该怎么做，一般我会,然后使用Function进行执行，但是这样有弊端，因为写法很随意，没有限制，
也有人可能使用立即执行的写法，或者`export default function`这种，这样我的`Funtion`中就要写好几种兼容的情况
```json
{
   "script":"()=>{xxxx}"
}
```
来看看amis是如何做的，手写amis中的交互类型有非常多，他们用actiionType区分，action可以进行registerAction，其实就是一个map对象，自定义动作他们使用doAction进行执行
```json
{
   "click": {
          "actions": [
            {
              "actionType": "custom",
              "script": "doAction({actionType: 'ajax', args: {api: 'https://3xsw4ap8wah59.cfc-execute.bj.baidubce.com/api/amis-mock/mock2/form/saveForm'}});\n //event.stopPropagation();"
            }
          ]
        }
}
```
来看一下他们的代码如何实现
```ts

    function str2Function(contents, ...args) {
      try {
        let fn = new Function(...args, contents);
        return fn;
      } catch (e) {
        console.warn(e);
        return null;
      }
    }


    scriptFunc = str2Function(scriptFunc, "context", "doAction");

     scriptFunc(null, (action) => {
        //   就是doAction的参数，这里就可以拿到actionType等数据
        console.log(action)
      });

```
于是我想在我们的低代码平台这样使用
```
{
   "script":"run(context, ()=>{ const a = context.a;})"
}
```
```tsx
scriptFunc({ a: 1 }, (context, callback) => {
   callback(context);
});
```

#### 7/10
1. 公网ip的作用
- 互联网访问：

公网IP地址是互联网上的唯一标识符，允许设备或服务器从互联网上的任何位置被直接访问。没有公网IP，服务器或设备将无法从互联网外部被直接访问，因为私网IP地址仅在局域网内是唯一的。

- 远程管理和服务：

公网IP对于需要远程管理服务器、网络设备或提供远程服务（如远程桌面、VPN、Web服务、FTP服务等）的组织来说至关重要。通过公网IP，管理员或用户可以远程登录到设备或服务器上，进行配置、监控或数据交换。

- 点对点通信：

在某些应用中，如P2P（点对点）文件共享、在线游戏、实时视频会议等，参与者之间需要直接通信。公网IP允许这些应用中的参与者通过互联网直接相互连接，而无需通过中间服务器进行中转。

- 物联网（IoT）设备：

随着物联网设备的普及，越来越多的设备需要接入互联网，以实现远程监控、控制或数据收集。这些设备通常需要公网IP地址，以便从任何位置进行访问和管理。
云服务：

- 云服务提供商（如AWS、Azure、Google Cloud等）为用户提供虚拟机、存储、数据库等云服务。这些服务通常分配有公网IP地址，以便用户可以从任何地方访问他们的云资源。
动态DNS（DDNS）：

对于家庭用户或小型企业来说，公网IP地址结合动态DNS服务可以实现远程访问家庭网络中的设备（如摄像头、NAS等）。当公网IP地址发生变化时，DDNS服务会更新DNS记录，以确保用户可以通过固定的域名访问这些设备。

-  安全性和防火墙规则：

公网IP地址可以用于配置网络安全设备（如防火墙）的访问控制列表（ACL）。管理员可以定义哪些公网IP地址或IP范围可以访问内部网络资源，从而增强网络的安全性。

- NAT（网络地址转换）的局限性：

虽然NAT技术允许私网地址的设备通过路由器访问互联网，但它也带来了一些限制。例如，NAT会隐藏内部设备的真实IP地址，使得从外部直接访问内部设备变得困难。此外，NAT还可能导致某些应用（如某些P2P应用）无法正常工作。因此，在某些情况下，使用公网IP地址是不可避免的。

2. ts中的小技巧
type Foo = {
  a: string;
  b: number;
}
type Bar = {
  a: string;
  c: boolean
}
type a = keyof (Foo | Bar)
我会任务a是`a|b|c`,但是只有`a`,因为他只会输出他确定的部分
一个更直观的例子：
假设我们有一个函数，它接受 Foo | Bar 类型的参数：
```ts
typescriptCopyfunction doSomething(obj: Foo | Bar) {
  console.log(obj.a);  // 这是安全的，因为我们知道无论是 Foo 还是 Bar，都有 a 属性
  console.log(obj.b);  // 错误！TypeScript 会警告这可能是不安全的
  console.log(obj.c);  // 错误！TypeScript 也会警告这可能是不安全的
}
```

#### 7/11
1. 工作当中完成材质对于物体的设置
2. ts中学到的小技巧，如下题
```ts
实现一个anyof
type AnyOf<T extends any[]> = T[number] extends 0 | '' | false | [] | {key:string:never}
? false : true;
// 这里我比较好奇的是为什么使用{key:string:never}而不是一个{}，因为在TypeScript中，{} 类型是一个特殊的类型，它表示任何非null和非undefined的值。这意味着它实际上匹配了所有的对象类型，包括数组和函数，甚至包括原始类型如数字、字符串和布尔值

type Sample1 = AnyOf<[1, '', false, [], {}]> // expected to be true.
type Sample2 = AnyOf<[0, '', false, [], {}]> // expected to be false.
```

3. 详细解析isUnion
您提出了一个很好的问题。这两点确实是理解这个类型定义的关键。让我们更深入地解释这两个概念：


1. 对于联合类型的成员分配：

当 `T` 是一个联合类型时，TypeScript 的条件类型会触发所谓的"分配"行为。这意味着条件类型会被应用到联合类型的每个成员上。让我们通过一个例子来说明：

假设 `T` 是 `string | number`，那么：

```typescript
T extends B ? [B] extends [T] ? false : true : never;
```

会被分解为：

```typescript
(string extends B ? [B] extends [string] ? false : true : never) |
(number extends B ? [B] extends [number] ? false : true : never)
```

在这个过程中：
- `T` 被分解为 `string` 和 `number`
- `B` 保持不变，仍然是 `string | number`

所以当我们检查 `[B] extends [T]` 时：
- 对于 `string`，我们实际上在检查 `[string | number] extends [string]`
- 对于 `number`，我们实际上在检查 `[string | number] extends [number]`

2. 非联合类型的情况：

如果 `T` 不是联合类型，比如就是一个 `string`，那么不会发生分配。整个表达式会被直接求值：

```typescript
string extends B ? [B] extends [string] ? false : true : never;
```

由于 `B` 默认等于 `T`（在这个例子中是 `string`），所以 `[B] extends [T]` 实际上变成了 `[string] extends [string]`，这显然是真的。

让我们通过具体的例子来说明：

```typescript
type IsUnion<T, B = T> = T extends B ? [B] extends [T] ? false : true : never;

type Test1 = IsUnion<string | number>;  // true
type Test2 = IsUnion<string>;  // false
```

对于 `Test1`：
1. `T` 是 `string | number`
2. 条件类型被分配到 `string` 和 `number`
3. 对于 `string`：`[string | number] extends [string]` 是假的
4. 对于 `number`：`[string | number] extends [number]` 是假的
5. 结果是 `true | true`，简化为 `true`

对于 `Test2`：
1. `T` 是 `string`
2. 不发生分配
3. `[string] extends [string]` 是真的
4. 结果是 `false`

这个技巧的核心在于利用了分配条件类型的行为与非分配情况下的行为之间的差异，从而区分联合类型和非联合类型。

希望这个更详细的解释能帮助您理解这个复杂的类型定义。如果您还有任何疑问，请随时问我。


#### 7/15
1. 完成了BI当中的材质模块
2. 使用vitepress搭建开源文档，其中想实现一个agent实现文本的翻译
3. langsmith，以及langchain中agent的概念 

#### 7/16
1. [UML教程](https://zhuanlan.zhihu.com/p/267298708)


#### 7/20
1. 今天打包xt-ui。复现一直包一个ts的错误，因为xt-ui是三年前写的了，所以node版本和pnpm的版本相对较低，但是现有项目使用的较高版本的pnpm，所以报错时我排查了依赖了版本，node的版本，最后才想到pnpm的版本，没想到pnpm版本较低也会有问题，所以还是要在package.json中加一个`packageManager`字段


#### 7/23
1. windows安装docker,直接下载安装之后，启动会报bios\wsl的错误，需要在控制面板->程序->启动或关闭windows,选择hype-v、容器、linux这几项，然后重启系统就可以了，https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP